Index: wireshark/epan/dissectors/packet-gsm_ipa.c
===================================================================
--- wireshark.orig/epan/dissectors/packet-gsm_ipa.c
+++ wireshark/epan/dissectors/packet-gsm_ipa.c
@@ -40,6 +40,8 @@
 static dissector_handle_t ipa_handle;
 static range_t *global_ipa_tcp_ports = NULL;
 static range_t *global_ipa_udp_ports = NULL;
+static gboolean global_ipa_in_root;
+static gboolean global_ipa_in_info;
 
 /* Initialize the protocol and registered fields */
 static int proto_ipa = -1;
@@ -47,6 +49,7 @@
 
 static int hf_ipa_data_len = -1;
 static int hf_ipa_protocol = -1;
+static int hf_ipa_hsl_debug = -1;
 
 static int hf_ipaccess_msgtype = -1;
 static int hf_ipaccess_attr_tag = -1;
@@ -73,6 +76,7 @@
 #define AIP_SCCP	0xfd
 #define ABISIP_IPACCESS	0xfe
 #define ABISIP_OML	0xff
+#define HSL_DEBUG	0xdd
 
 static const value_string ipa_protocol_vals[] = {
 	{ 0x00,		"RSL" },
@@ -80,6 +84,7 @@
 	{ 0xfd,		"SCCP" },
 	{ 0xfe,		"IPA" },
 	{ 0xff,		"OML" },
+	{ 0xdd,		"HSL Debug" },
 	{ 0, 		NULL }
 };
 
@@ -187,7 +192,7 @@
 
 	while ((remaining = tvb_reported_length_remaining(tvb, offset)) > 0) {
 		proto_item *ti;
-		proto_tree *ipa_tree;
+		proto_tree *ipa_tree = NULL;
 		guint16 len, msg_type;
 		tvbuff_t *next_tvb;
 
@@ -241,6 +246,18 @@
 			/* hand this off to the standard MGCP dissector */
 			call_dissector(sub_handles[SUB_MGCP], next_tvb, pinfo, tree);
 			break;
+		case HSL_DEBUG:
+			if (tree) {
+				proto_tree_add_item(ipa_tree, hf_ipa_hsl_debug,
+						    next_tvb, 0, len, FALSE);
+				if (global_ipa_in_root == TRUE)
+					proto_tree_add_item(tree, hf_ipa_hsl_debug,
+							    next_tvb, 0, len, FALSE);
+			}
+			if (global_ipa_in_info == TRUE)
+				col_append_fstr(pinfo->cinfo, COL_INFO, "%s ",
+						tvb_get_stringz(next_tvb, 0, NULL));
+			break;
 		default:
 			if (msg_type < ABISIP_RSL_MAX) {
 				/* hand this off to the standard A-bis RSL dissector */
@@ -269,6 +286,11 @@
 		  FT_UINT8, BASE_HEX, VALS(ipa_protocol_vals), 0x0,
 		  "The IPA Sub-Protocol", HFILL}
 		 },
+		{&hf_ipa_hsl_debug,
+		 {"Debug Message", "ipa.hsl_debug",
+		  FT_STRING, BASE_NONE, NULL, 0,
+		  NULL, HFILL}
+		},
 	};
 	static hf_register_info hf_ipa[] = {
 		{&hf_ipaccess_msgtype,
@@ -321,6 +343,13 @@
 					"Set the port(s) for ip.access IPA"
 					" (default: " IPA_UDP_PORTS ")",
 					&global_ipa_udp_ports, MAX_UDP_PORT);
+
+	prefs_register_bool_preference(ipa_module, "hsl_debug_in_root_tree",
+					"HSL Debug messages in root protocol tree",
+					NULL, &global_ipa_in_root);
+	prefs_register_bool_preference(ipa_module, "hsl_debug_in_info",
+					"HSL Debug messages in INFO column",
+					NULL, &global_ipa_in_info);
 }
 
 static void ipa_tcp_delete_callback(guint32 port)
